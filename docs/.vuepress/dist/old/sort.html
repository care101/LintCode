<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>排序算法 | Algorithm Book</title>
    <meta name="description" content="My Algorithm Notes">
    
    
    <link rel="preload" href="/LintCode/assets/css/styles.a17bf1aa.css" as="style"><link rel="preload" href="/LintCode/assets/js/app.a17bf1aa.js" as="script"><link rel="preload" href="/LintCode/assets/js/18.2fa50776.js" as="script"><link rel="prefetch" href="/LintCode/assets/js/5.bca79e25.js"><link rel="prefetch" href="/LintCode/assets/css/1.styles.b780958f.css"><link rel="prefetch" href="/LintCode/assets/js/1.b780958f.js"><link rel="prefetch" href="/LintCode/assets/css/2.styles.993fa36d.css"><link rel="prefetch" href="/LintCode/assets/js/2.993fa36d.js"><link rel="prefetch" href="/LintCode/assets/js/3.d69d32c5.js"><link rel="prefetch" href="/LintCode/assets/js/4.43750586.js"><link rel="prefetch" href="/LintCode/assets/js/6.0ed1ce10.js"><link rel="prefetch" href="/LintCode/assets/js/7.8add1805.js"><link rel="prefetch" href="/LintCode/assets/js/8.81279d64.js"><link rel="prefetch" href="/LintCode/assets/js/9.4ff1fc7a.js"><link rel="prefetch" href="/LintCode/assets/js/10.189faa58.js"><link rel="prefetch" href="/LintCode/assets/js/11.91da4f03.js"><link rel="prefetch" href="/LintCode/assets/js/12.dce3ad83.js"><link rel="prefetch" href="/LintCode/assets/js/13.8764b80f.js"><link rel="prefetch" href="/LintCode/assets/js/14.3f1cdf02.js"><link rel="prefetch" href="/LintCode/assets/js/15.ac8f3f30.js"><link rel="prefetch" href="/LintCode/assets/js/16.93025194.js"><link rel="prefetch" href="/LintCode/assets/js/17.1c763f8d.js"><link rel="prefetch" href="/LintCode/assets/js/19.d691559a.js"><link rel="prefetch" href="/LintCode/assets/js/20.4a181c74.js"><link rel="prefetch" href="/LintCode/assets/js/21.32481899.js">
    <link rel="stylesheet" href="/LintCode/assets/css/styles.a17bf1aa.css"><link rel="stylesheet" href="/LintCode/assets/css/1.styles.b780958f.css"><link rel="stylesheet" href="/LintCode/assets/css/2.styles.993fa36d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/LintCode/" class="home-link router-link-active"><!----> <span class="site-name">Algorithm Book</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/LintCode/" class="nav-link">Home</a></div><div class="nav-item"><a href="https://github.com/Kexin-Li/LintCode" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/LintCode/" class="nav-link">Home</a></div><div class="nav-item"><a href="https://github.com/Kexin-Li/LintCode" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/LintCode/" class="sidebar-link">Home</a></li><li><a href="/LintCode/sort/" class="sidebar-link">排序算法</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="排序算法"><a href="#排序算法" aria-hidden="true" class="header-anchor">#</a> 排序算法</h1> <p>本文记录了常用的排序算法，按照时间复杂度的分类方式，分为时间复杂度为 <code>O(n^2)</code> 的算法，<code>O(nlogn)</code> 的算法和 <code>O(n)</code> 的算法依此讲解。</p> <h2 id="时间复杂度为-o-n-2-的算法"><a href="#时间复杂度为-o-n-2-的算法" aria-hidden="true" class="header-anchor">#</a> 时间复杂度为 <code>O(n^2)</code> 的算法</h2> <p>常见的时间复杂度为 <code>O(n^2)</code> 的算法有冒泡排序，选择排序以及插入排序。</p> <h3 id="冒泡排序"><a href="#冒泡排序" aria-hidden="true" class="header-anchor">#</a> 冒泡排序</h3> <p>首先是第一个数和第二个数进行比较，谁大谁在后面，接着第二个数和第三个数进行比较，谁大谁在后面。以此类推，经过一轮比较下来最大的数就沉到了最后一位。将数组范围缩小到 0-N-1，再经历一轮第二大的数就在倒数第二的位置。以此类推，当数组范围只剩一个数时，数组就变得有序了。</p> <p><a href="https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/BubbleSort.js" target="_blank" rel="noopener noreferrer">JavaScript 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/BubbleSort.py" target="_blank" rel="noopener noreferrer">Python 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt="可视化过程"></p> <h3 id="选择排序"><a href="#选择排序" aria-hidden="true" class="header-anchor">#</a> 选择排序</h3> <p>首先在整个数组中选出最小的数放在最前面，接着在剩下的数组中选出最小的数放在第二个位置。以此类推，当剩下的数组只剩一个数时，整个数组就变得有序了。</p> <p><a href="https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/SelectSort.js" target="_blank" rel="noopener noreferrer">JavaScript 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/SelectSort.py" target="_blank" rel="noopener noreferrer">Python 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="可视化过程"></p> <h3 id="插入排序"><a href="#插入排序" aria-hidden="true" class="header-anchor">#</a> 插入排序</h3> <p>首先将第二个位置和第一个位置的数进行比较，谁小谁在前。第三个位置上的数和第一、二个位置上的数比较，插入合适的位置。第四个位置上的数和第一、二、三个位置上的数比较，插入合适的位置。以此类推，当安顿好了数组的最后一个数，整个数组也变得有序了。</p> <p><a href="https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/InsertSort.js" target="_blank" rel="noopener noreferrer">JavaScript 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/InsertSort.py" target="_blank" rel="noopener noreferrer">Python 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="可视化过程"></p> <h2 id="时间复杂度为-o-nlogn-的算法"><a href="#时间复杂度为-o-nlogn-的算法" aria-hidden="true" class="header-anchor">#</a> 时间复杂度为 <code>O(nlogn)</code> 的算法</h2> <p>常见的时间复杂度为 <code>O(nlogn)</code> 的算法有归并排序、快速排序、堆排序以及希尔排序。</p> <h3 id="归并排序"><a href="#归并排序" aria-hidden="true" class="header-anchor">#</a> 归并排序</h3> <p>首先将数组中的每一个数看作长度为 1 的有序序列，然后把相邻的有序序列进行合并操作，得到最大长度为 2 的有序序列。接着再把相邻序列进行合并，得到最大程度为 4 的有序序列。以此类推，直到数组中的所有数合并成一个有序序列。</p> <p>所以归并排序的思想在于<strong>将两两有序序列合并成一个有序序列</strong>。</p> <p><a href="https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/MergeSort.js" target="_blank" rel="noopener noreferrer">JavaScript 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/MergeSort.py" target="_blank" rel="noopener noreferrer">Python 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt="可视化过程"></p> <h3 id="快速排序"><a href="#快速排序" aria-hidden="true" class="header-anchor">#</a> 快速排序</h3> <p>首先在数组中随机选一个作为基准数(一般选择中点位置的数)，接着将数组中小于等于基准数的放到数组左边，大于基准数的放到数组右边，使得整个数组整体有序。然后再对左右两边分别递归调用上述过程，从而使整个数组有序。</p> <p><a href="https://github.com/Kexin-Li/LintCode/blob/master/JavaScript/sort/QuickSort.js" target="_blank" rel="noopener noreferrer">JavaScript 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, <a href="https://github.com/Kexin-Li/LintCode/blob/master/Python/sort/QuickSort.py" target="_blank" rel="noopener noreferrer">Python 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="可视化过程"></p> <h3 id="堆排序"><a href="#堆排序" aria-hidden="true" class="header-anchor">#</a> 堆排序</h3> <p>首先将数组中的 N 个数建成一个大小为 N 的大根堆，堆顶是所有元素中的最大值，将堆顶元素与堆的最后一个元素进行交换，将最大值脱离堆并作为有序部分放在数组的末尾。接着调整大根堆，将剩下元素的最大值放在堆顶然后脱离堆，加入有序部分。以此类推，当堆只剩下一个元素时，整个数组就有序了。</p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" alt="可视化过程"></p> <h3 id="希尔排序"><a href="#希尔排序" aria-hidden="true" class="header-anchor">#</a> 希尔排序</h3> <p>希尔排序是插入排序的改良版。插入排序的步长是 1，希尔排序的步长是从大到小逐渐调整的。</p> <p>初始的步长需要我们来制定，比如 <code>6 5 3 1 8 7 2 4</code> 这个数组，我们选择初始步长为 3，那么 <code>6 5 3</code> 这前三个数可以暂不做调整。接着从 1 开始向前跳三位，与 6 进行比较，进而交换位置，再往前跳三位由于越界了所以不作调整了。然后看 8 这位数，向前跳三位与 5 比较，由于 8 &gt; 5 所以不做调整。以此调整完整个数组，再修改步长为 2 和 1 再分别对数组做调整。</p> <p>希尔排序的时间复杂度高低完全取决于步长的选择，步长选择越优那么它的时间复杂度越低，反之时间复杂度就越高。</p> <h2 id="时间复杂度为-o-n-的算法"><a href="#时间复杂度为-o-n-的算法" aria-hidden="true" class="header-anchor">#</a> 时间复杂度为 <code>O(n)</code> 的算法</h2> <p>时间复杂度为 <code>O(n)</code> 的算法都不是基于比较的思想，而是基于<a href="https://zh.wikipedia.org/zh-hant/%E6%A1%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener noreferrer">桶排序<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的思想。常见的有计数排序和基数排序。</p> <h3 id="计数排序"><a href="#计数排序" aria-hidden="true" class="header-anchor">#</a> 计数排序</h3> <p>详见<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener noreferrer">计数排序<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="基数排序"><a href="#基数排序" aria-hidden="true" class="header-anchor">#</a> 基数排序</h3> <p>详见<a href="https://zh.wikipedia.org/zh-hant/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener noreferrer">计数排序<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <table><thead><tr><th>名称</th> <th style="text-align:center">时间复杂度</th> <th style="text-align:center">空间复杂度</th> <th style="text-align:center">稳定性</th></tr></thead> <tbody><tr><td>冒泡排序</td> <td style="text-align:center"><code>O(n^2)</code></td> <td style="text-align:center"><code>O(1)</code></td> <td style="text-align:center">稳定</td></tr> <tr><td>选择排序</td> <td style="text-align:center"><code>O(n^2)</code></td> <td style="text-align:center"><code>O(1)</code></td> <td style="text-align:center">不稳定</td></tr> <tr><td>插入排序</td> <td style="text-align:center"><code>O(n^2)</code></td> <td style="text-align:center"><code>O(1)</code></td> <td style="text-align:center">稳定</td></tr> <tr><td>归并排序</td> <td style="text-align:center"><code>O(n*logn)</code></td> <td style="text-align:center"><code>O(n)</code></td> <td style="text-align:center">稳定</td></tr> <tr><td>快速排序</td> <td style="text-align:center"><code>O(n*logn)</code></td> <td style="text-align:center"><code>O(logn)</code> ~ <code>O(n)</code></td> <td style="text-align:center">不稳定</td></tr> <tr><td>堆排序</td> <td style="text-align:center"><code>O(n*logn)</code></td> <td style="text-align:center"><code>O(1)</code></td> <td style="text-align:center">不稳定</td></tr> <tr><td>希尔排序</td> <td style="text-align:center"><code>O(n*logn)</code></td> <td style="text-align:center"><code>O(1)</code></td> <td style="text-align:center">不稳定</td></tr> <tr><td>计数排序</td> <td style="text-align:center"><code>O(n)</code></td> <td style="text-align:center"><code>O(m)</code></td> <td style="text-align:center">稳定</td></tr> <tr><td>基数排序</td> <td style="text-align:center"><code>O(n)</code></td> <td style="text-align:center"><code>O(m)</code></td> <td style="text-align:center">稳定</td></tr></tbody></table> <p><strong>Notes：</strong></p> <ul><li>计数排序与基数排序中的空间复杂度 <code>O(m)</code> 中的 m 指的是桶的数量。</li> <li>稳定性：指相同值的元素在排序前和排序后的相对次序是否保持不变。</li> <li>桶排序虽然时间复杂度高，但可以理解为是一种空间换时间的思想。当数据量很大时，需要准备的桶也就越多，会一定程序造成空间的浪费。因此具有很大的局限性。</li> <li>快速排序之所以叫快速排序，不是因为它比堆排序、归并排序更优良，而是因为它的常量系数比较低。</li> <li>在工程中，并不会特定使用某一种排序，而是综合使用。比如当元素个数比较少时，会使用插入排序；当元素个数较多时，会使用快速排序。</li></ul></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">10/14/2018, 2:00:25 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/LintCode/assets/js/18.2fa50776.js" defer></script><script src="/LintCode/assets/js/app.a17bf1aa.js" defer></script>
  </body>
</html>
